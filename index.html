<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
  <title>Galaxia del Amor ‚Äî Multiling√ºe</title>
  <meta name="description" content="Galaxia 3D interactiva con 'Te amo' en muchos idiomas. Optimizada para iPhone 11 y Samsung Galaxy S21 Ultra." />
  <style>
    :root{ --bg1:#0a0318; --bg2:#1a0b2e; --white:#ffffff; }
    html, body { height: 100%; }
    body{
      margin:0; overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--white);
      background: radial-gradient(1200px 800px at 70% 20%, #2a174a 0%, transparent 40%),
                  radial-gradient(1000px 700px at 20% 80%, #1e0f36 0%, transparent 45%),
                  radial-gradient(100% 120% at 50% 50%, var(--bg2), var(--bg1));
      background-attachment: fixed;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      touch-action: none;            /* pasamos gestos al lienzo */
      overscroll-behavior: none;     /* evita rebotes */
    }
    #scene { position: fixed; inset: 0; }
    #badge { position: fixed; left: 12px; bottom: env(safe-area-inset-bottom, 12px); opacity: .35; font-size: 12px; letter-spacing: .3px; }
  </style>
</head>
<body>
  <div id="scene" aria-label="Galaxia 3D con 'Te amo' en muchos idiomas"></div>
  <div id="badge" aria-hidden="true"></div>

  <!-- C√≥digo principal como ES Module utilizando URL expl√≠citas (sin import maps) -->
  <script type="module">
  import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';

  (function(){
    'use strict';

    function ready(fn){ if (document.readyState !== 'loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }

    ready(()=>{
      try {
        // === Detecci√≥n de dispositivo ===
        function deviceClass(){
          const w = Math.min(window.innerWidth, window.innerHeight);
          const h = Math.max(window.innerWidth, window.innerHeight);
          const approx = (a,b,eps)=> Math.abs(a-b) <= eps;
          if ( (approx(w,414,3) && approx(h,896,10)) ) return 'iphone11';
          if ( (approx(w,412,4) && approx(h,919,12)) ) return 's21u';
          if (w <= 430) return 'mobile';
          return 'desktop';
        }
        const DEV = deviceClass();
        const badge = document.getElementById('badge');
        if (badge) badge.textContent = DEV.toUpperCase();

        // === Three.js base ===
        const container = document.getElementById('scene');
        if (!container) throw new Error('Contenedor #scene no encontrado');

        const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
        const targetDPR = (DEV==='desktop') ? 2.5 : 2.0;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, targetDPR));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.style.touchAction = 'none';
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        if (DEV==='iphone11') camera.position.set(0, 16, 92);
        else if (DEV==='s21u') camera.position.set(0, 18, 96);
        else if (DEV==='mobile') camera.position.set(0, 18, 94);
        else camera.position.set(0, 18, 84);
        camera.lookAt(0,0,0);

        const galaxy = new THREE.Group();
        scene.add(galaxy);

        // Luces
        scene.add(new THREE.AmbientLight(0xffffff, 0.65));
        const dir = new THREE.DirectionalLight(0xffffff, 0.75); dir.position.set(60, 100, 40); scene.add(dir);

        // === Estrellas de fondo ===
        (function createStarfield(){
          const COUNT = (DEV==='desktop') ? 1600 : 1100;
          const geo = new THREE.BufferGeometry();
          const pos = new Float32Array(COUNT * 3);
          for (let i=0;i<COUNT;i++){
            const r = THREE.MathUtils.randFloat(180, 480);
            const phi = Math.random() * Math.PI * 2;
            const costheta = THREE.MathUtils.randFloat(-1, 1);
            const theta = Math.acos(costheta);
            pos[i*3+0] = r * Math.sin(theta) * Math.cos(phi);
            pos[i*3+1] = r * Math.sin(theta) * Math.sin(phi);
            pos[i*3+2] = r * Math.cos(theta);
          }
          geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
          const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.0, sizeAttenuation: true, transparent: true, opacity: 0.8 });
          galaxy.add(new THREE.Points(geo, mat));
        })();

        // === Galaxia espiral ===
        function createGalaxy(){
          const count = (DEV==='desktop') ? 12000 : 9000;
          const geo = new THREE.BufferGeometry();
          const pos = new Float32Array(count * 3);
          const col = new Float32Array(count * 3);
          const insideColor = new THREE.Color('#ff2d95');
          const outsideColor = new THREE.Color('#7c4dff');
          for (let i=0;i<count;i++){
            const r = Math.pow(Math.random(), 0.8) * 60;
            const branch = i % 5;
            const branchAngle = (branch / 5) * Math.PI * 2;
            const spinAngle = r * 1.4;
            const randomX = Math.pow(Math.random(), 2.6) * (Math.random()<0.5?1:-1) * 0.7 * r;
            const randomY = Math.pow(Math.random(), 2.6) * (Math.random()<0.5?1:-1) * 0.28 * r;
            const randomZ = Math.pow(Math.random(), 2.6) * (Math.random()<0.5?1:-1) * 0.7 * r;
            const x = Math.cos(branchAngle + spinAngle) * r + randomX;
            const y = randomY * 0.3;
            const z = Math.sin(branchAngle + spinAngle) * r + randomZ;
            pos[i*3+0]=x; pos[i*3+1]=y; pos[i*3+2]=z;
            const c = insideColor.clone().lerp(outsideColor, r / 60);
            col[i*3+0]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
          }
          geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
          geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
          const mat = new THREE.PointsMaterial({ size: (DEV==='desktop') ? 0.9 : 0.85, sizeAttenuation:true, depthWrite:false, blending: THREE.AdditiveBlending, vertexColors:true, transparent:true });
          const points = new THREE.Points(geo, mat);
          galaxy.add(points);
          return { geometry: geo, points };
        }
        const galaxyPoints = createGalaxy();

        // === "Te amo" en muchos idiomas (sin indicar idioma) ===
        const LOVE_PHRASES = [
          "Te amo","I love you","Je t'aime","Ti amo","Ich liebe dich","Eu te amo","Amo-te","S'agapo","Te iubesc","T'estimo",
          "Maite zaitut","Volim te","Kocham ciƒô","Milujem ≈•a","Szeretlek","Ljublim te","–Ø —Ç–µ–±—è –ª—é–±–ª—é","–Ø –∫–æ—Ö–∞—é —Ç–µ–±–µ",
          "ÿ£ÿ≠ÿ®ŸÉ","◊ê◊†◊ô ◊ê◊ï◊î◊ë ◊ê◊ï◊™◊ö","Seni seviyorum","ÿ™Ÿà ÿ±ÿß ÿØŸàÿ≥ÿ™ ÿØÿßÿ±ŸÖ",
          "‡§Æ‡•à‡§Ç ‡§§‡•Å‡§Æ‡§∏‡•á ‡§™‡•ç‡§Ø‡§æ‡§∞ ‡§ï‡§∞‡§§‡§æ ‡§π‡•Ç‡§Å","‡¶Ü‡¶Æ‡¶ø ‡¶§‡ßã‡¶Æ‡¶æ‡¶ï‡ßá ‡¶≠‡¶æ‡¶≤‡¶¨‡¶æ‡¶∏‡¶ø","‡∂∏‡∂∏ ‡∂î‡∂∫‡∑è‡∂ß ‡∂Ü‡∂Ø‡∂ª‡∑ô‡∂∫‡∑í","‡≤Æ‡≥Ü ‡≤®‡≤ø‡≤®‡≥ç‡≤®‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≥ç‡≤∞‡≥Ä‡≤§‡≤ø‡≤∏‡≥Å‡≤§‡≥ç‡≤§‡≥á‡≤®‡≥Ü","‡Æ®‡Ææ‡Æ©‡Øç ‡Æâ‡Æ©‡Øç‡Æ©‡Øà ‡Æï‡Ææ‡Æ§‡Æ≤‡Æø‡Æï‡Øç‡Æï‡Æø‡Æ±‡Øá‡Æ©‡Øç","‡¥û‡¥æ‡µª ‡¥®‡¥ø‡¥®‡µç‡¥®‡µÜ ‡¥∏‡µç‡¥®‡µá‡¥π‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ",
          "ŸÖ€å⁄∫ ÿ™ŸÖ ÿ≥€í Ÿæ€åÿßÿ± ⁄©ÿ±ÿ™ÿß €ÅŸà⁄∫","‡§Æ ‡§§‡§ø‡§Æ‡•Ä‡§≤‡§æ‡§à ‡§Æ‡§æ‡§Ø‡§æ ‡§ó‡§∞‡•ç‡§õ‡•Å","‡ΩÑ‡ºã‡ΩÅ‡æ±‡Ω∫‡Ωë‡ºã‡Ω£‡ºã‡Ωë‡ΩÇ‡Ω†‡ºã‡Ωî‡Ωº‡ºã‡Ω°‡Ωº‡Ωë‡ºã",
          "ÊàëÁà±‰Ω†","ÊàëÊÑõ‰Ω†","ÊÑõ„Åó„Å¶„Çã","ÏÇ¨ÎûëÌï¥","‡∫Ç‡ªâ‡∫≠‡∫ç‡∫Æ‡∫±‡∫Å‡ªÄ‡∫à‡∫ª‡ªâ‡∫≤","·Äô·ÄÑ·Ä∫·Ä∏·ÄÄ·Ä≠·ÄØ·ÄÅ·Äª·ÄÖ·Ä∫·Äê·Äö·Ä∫","·ûÅ·üí·ûâ·ûª·üÜ·ûü·üí·ûö·û°·û∂·ûâ·üã·û¢·üí·ûì·ûÄ",
          "Aku cinta kamu","Mahal kita","Aroha ahau ki a koe","Aloha wau iƒÅ 'oe",
          "Nakupenda","Ndinokuda","Ek s√™ lief vir jou","Niyakuthanda","Mwen renmen ou",
          "Nimitztlazotla","Kuyayki","Rohayhu",
          "‚ù§","‚ô•","üíú","üíô","üíñ","üíó"
        ];

        const labelGroup = new THREE.Group();
        galaxy.add(labelGroup);
        const sprites = [];

        // === Estilos de etiqueta (m√°s peque√±as; m√°s separaci√≥n) ===
        function computeLabelStyle(){
          if (DEV==='iphone11'){
            return { fontSize: 20, padding: 6, baseHeight: 1.45, hoverScale: 1.07, minSep: 7.2, innerGap: 26 };
          }
          if (DEV==='s21u'){
            return { fontSize: 20, padding: 6, baseHeight: 1.5, hoverScale: 1.07, minSep: 7.2, innerGap: 26 };
          }
          if (DEV==='mobile'){
            return { fontSize: 22, padding: 7, baseHeight: 1.6, hoverScale: 1.07, minSep: 7.5, innerGap: 26 };
          }
          return { fontSize: 42, padding: 14, baseHeight: 2.6, hoverScale: 1.1, minSep: 7.5, innerGap: 24 };
        }
        let labelStyle = computeLabelStyle();

        function makeTextSprite(text){
          const { fontSize, padding } = labelStyle;
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          ctx.font = `700 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
          const metrics = ctx.measureText(text);
          const w = Math.ceil(metrics.width + padding * 2);
          const h = Math.ceil(fontSize + padding * 2);
          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          canvas.width = w * dpr; canvas.height = h * dpr;
          ctx.scale(dpr, dpr);
          ctx.fillStyle = 'rgba(255,255,255,0.08)';
          ctx.fillRect(0, 0, w, h);
          ctx.fillStyle = '#ffffff';
          ctx.strokeStyle = 'rgba(12,6,30,0.85)';
          ctx.lineWidth = Math.max(2, Math.floor(fontSize * 0.06));
          ctx.shadowColor = 'rgba(160,240,255,0.45)';
          ctx.shadowBlur = 9; ctx.shadowOffsetY = 1;
          ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
          ctx.font = `800 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
          // (no mostramos idioma; solo la frase)
          const clean = String(text).replace(/\s*\([^)]*\)\s*/g,' ').replace(/\s+/g,' ').trim();
          ctx.fillText(clean, padding, h/2 + 1);
          ctx.strokeText(clean, padding, h/2 + 1);
          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
          const material = new THREE.SpriteMaterial({ map: texture, transparent:true, depthWrite:false, depthTest:false });
          const sprite = new THREE.Sprite(material);
          const baseHeight = labelStyle.baseHeight;
          const aspect = canvas.width / canvas.height;
          sprite.scale.set(baseHeight * aspect, baseHeight, 1);
          sprite.userData = { baseHeight, text };
          return sprite;
        }

        function populatePhrasesOnGalaxy(list){
          // limpiar
          for (const s of sprites){ labelGroup.remove(s); s.material.map.dispose(); s.material.dispose(); }
          sprites.length = 0;

          const posAttr = galaxyPoints.geometry.getAttribute('position');
          const totalPos = posAttr.count;
          const INNER_GAP = labelStyle.innerGap;
          const MIN_SEP  = labelStyle.minSep;
          const isMobile = (DEV!=='desktop');
          const MAX_SPRITES = Math.min(list.length, Math.min(isMobile ? 80 : 140, totalPos));
          const STEP = Math.max(1, Math.floor(totalPos / MAX_SPRITES));

          function tooCloseXYZ(x,y,z){
            for (const s of sprites){
              const dx = x - s.position.x;
              const dz = z - s.position.z;
              const dy = (y - s.position.y) * 0.5;
              if (dx*dx + dz*dz + dy*dy < MIN_SEP*MIN_SEP) return true;
            }
            return false;
          }

          // Rejilla de ocupaci√≥n en pantalla para evitar solapes visuales
          const gridW = isMobile ? 18 : 22; // columnas
          const gridH = isMobile ? 28 : 30; // filas
          const occupied = new Set();
          const keyOf = (nx,ny)=> nx+','+ny;

          for (let i=0; i<MAX_SPRITES; i++){
            const text = list[i % list.length];
            const sp = makeTextSprite(text);
            const base = i * STEP;
            const jitterSpan = Math.max(2, STEP * 0.25);
            let placed = false;
            for (let attempt=0; attempt<16 && !placed; attempt++){
              const jitter = Math.floor((Math.random() - 0.5) * jitterSpan);
              const idx = Math.min(totalPos - 1, Math.max(0, base + jitter));
              let x = posAttr.getX(idx);
              let y = posAttr.getY(idx);
              let z = posAttr.getZ(idx);
              const r2 = Math.hypot(x, z);
              if (r2 < INNER_GAP){
                const newR = INNER_GAP + Math.random() * 10;
                const scale = newR / (r2 || 1e-4);
                x *= scale; z *= scale;
              }
              x += (Math.random() - 0.5) * 3.2;
              z += (Math.random() - 0.5) * 3.2;

              // proyectar a NDC para reservar celda de pantalla
              const v = new THREE.Vector3(x,y,z); v.project(camera);
              if (v.z < -1 || v.z > 1) continue; // fuera de clip
              const nx = Math.floor((v.x*0.5+0.5) * gridW);
              const ny = Math.floor((-v.y*0.5+0.5) * gridH);
              const k = keyOf(nx,ny);
              if (occupied.has(k)) continue;

              if (!tooCloseXYZ(x,y,z)){
                sp.position.set(x, y, z);
                occupied.add(k);
                placed = true;
              }
            }

            if (!placed){
              // Empujar afuera como √∫ltimo recurso
              let x = posAttr.getX(base), y = posAttr.getY(base), z = posAttr.getZ(base);
              const r2 = Math.hypot(x, z); const newR = Math.max(INNER_GAP+14, r2 + 14);
              const scale = newR / (r2 || 1e-4);
              x *= scale; z *= scale; sp.position.set(x,y,z);
            }

            labelGroup.add(sp); sprites.push(sp);
          }
        }

        function shuffleArray(arr){ const a=[...arr]; for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
        function randomizePhrases(){
          const labels = shuffleArray([...LOVE_PHRASES, ...LOVE_PHRASES]); // duplicamos para densidad uniforme
          populatePhrasesOnGalaxy(labels);
        }
        randomizePhrases();

        // === Controles: 1 dedo rota galaxia; 2 dedos pinch-zoom + pan; rueda = zoom ===
        let controls = { update(){} };
        (function createBasicControls(){
          const dom = renderer.domElement;
          const state = { dragging:false, lastX:0, lastY:0, pointers:new Map(), lastDist:0, lastCentroid:null };

          function panBy(dx, dy){
            const panScale = (camera.position.z / Math.max(window.innerWidth, window.innerHeight)) * 1.2;
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
            const up = camera.up.clone().normalize();
            camera.position.addScaledVector(right, -dx * panScale);
            camera.position.addScaledVector(up,    dy * panScale);
            camera.lookAt(0,0,0);
          }

          dom.addEventListener('pointerdown', e=>{
            state.dragging=true; state.lastX=e.clientX; state.lastY=e.clientY; dom.setPointerCapture(e.pointerId);
            state.pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
          });
          dom.addEventListener('pointerup', e=>{
            state.dragging=false; state.pointers.delete(e.pointerId); state.lastDist=0; state.lastCentroid=null;
          });
          dom.addEventListener('pointercancel', e=>{
            state.dragging=false; state.pointers.clear(); state.lastDist=0; state.lastCentroid=null;
          });
          dom.addEventListener('pointermove', e=>{
            state.pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});

            // 1 dedo: rotaci√≥n de galaxia
            if (state.pointers.size===1 && state.dragging){
              const dx = e.clientX - state.lastX; const dy = e.clientY - state.lastY;
              state.lastX = e.clientX; state.lastY = e.clientY;
              galaxy.rotation.y += dx * 0.005;
              galaxy.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, galaxy.rotation.x + dy * 0.003));
            }

            // 2 dedos: pinch + pan
            if (state.pointers.size===2){
              const pts = Array.from(state.pointers.values());
              const dx = pts[0].x - pts[1].x; const dy = pts[0].y - pts[1].y;
              const dist = Math.hypot(dx,dy);
              const centroid = { x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2 };
              if (state.lastDist){
                const delta = (state.lastDist - dist) * 0.02; // zoom
                camera.position.z = THREE.MathUtils.clamp(camera.position.z + delta, 20, 220);
              }
              if (state.lastCentroid){
                const cdx = centroid.x - state.lastCentroid.x; const cdy = centroid.y - state.lastCentroid.y;
                panBy(cdx, cdy);
              }
              state.lastDist = dist; state.lastCentroid = centroid;
            }
          }, { passive:true });

          dom.addEventListener('wheel', e=>{
            e.preventDefault();
            camera.position.z = THREE.MathUtils.clamp(camera.position.z + e.deltaY * 0.02, 20, 220);
          }, { passive:false });
        })();

        // === Hover sutil (agranda) ===
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(2,2); // fuera al inicio
        let hovered = null;
        function updateRaycast(){
          raycaster.setFromCamera(mouse, camera);
          const hit = raycaster.intersectObjects(sprites, false);
          if (hit.length){
            const obj = hit[0].object;
            if (hovered !== obj){
              if (hovered){ hovered.scale.set(hovered.userData.baseScaleX, hovered.userData.baseScaleY, 1); }
              hovered = obj;
              hovered.userData.baseScaleX = hovered.scale.x;
              hovered.userData.baseScaleY = hovered.scale.y;
              hovered.scale.set(hovered.scale.x * labelStyle.hoverScale, hovered.scale.y * labelStyle.hoverScale, 1);
            }
          } else {
            if (hovered){ hovered.scale.set(hovered.userData.baseScaleX, hovered.userData.baseScaleY, 1); }
            hovered = null;
          }
        }
        renderer.domElement.addEventListener('pointermove', e=>{
          const rect = renderer.domElement.getBoundingClientRect();
          mouse.set(((e.clientX-rect.left)/rect.width)*2-1, -((e.clientY-rect.top)/rect.height)*2+1);
        }, { passive:true });

        // === Resize ===
        window.addEventListener('resize', ()=>{
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          const newStyle = computeLabelStyle();
          if (newStyle.baseHeight !== labelStyle.baseHeight || newStyle.fontSize !== labelStyle.fontSize){
            labelStyle = newStyle; randomizePhrases();
          }
        });

        // === Animaci√≥n ===
        let t0 = performance.now();
        function animate(){
          const now = performance.now();
          const dt = (now - t0) / 1000; t0 = now;
          galaxy.rotation.y += dt * 0.12;
          const wobble = 1 + Math.sin(now * 0.008) * 0.03;
          const camPos = camera.position;
          for (const s of sprites){
            const dist = s.position.distanceTo(camPos);
            const k = THREE.MathUtils.clamp(THREE.MathUtils.mapLinear(dist, 10, 180, 1.3, 4.0), 1.15, 4.2);
            const h = s.userData.baseHeight * k * wobble;
            const aspect = s.scale.x / s.scale.y;
            s.scale.set(h * aspect, h, 1);
            s.position.y += Math.sin(now * 0.001 + s.position.x * 0.02 + s.position.z * 0.02) * 0.0035;
          }
          updateRaycast();
          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        }
        animate();

        // === Self-tests m√≠nimos ===
        setTimeout(()=>{
          const a0 = galaxy.rotation.y;
          setTimeout(()=>{ const a1 = galaxy.rotation.y; console.assert(a1 !== a0, 'La galaxia no est√° girando'); }, 160);
        }, 0);

      } catch (err) {
        const note = document.createElement('pre');
        note.textContent = 'Fallo de arranque: ' + (err && err.message ? err.message : err);
        Object.assign(note.style, {
          position:'fixed', left:'50%', top:'20px', transform:'translateX(-50%)',
          background:'rgba(0,0,0,.75)', color:'#fff', padding:'12px 16px', borderRadius:'12px',
          fontFamily:'monospace', fontSize:'12px', zIndex:9999,
          border:'1px solid rgba(255,255,255,.25)', maxWidth:'90vw', whiteSpace:'pre-wrap'
        });
        document.body.appendChild(note);
        console.error(err);
      }
    });
  })();
  </script>
</body>
</html>
