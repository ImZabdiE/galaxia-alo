<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
  <title>Galaxia del Amor — Multilingüe</title>
  <meta name="description" content="Galaxia 3D interactiva con 'Te amo' en muchos idiomas. Optimizada para iPhone 11 y Samsung Galaxy S21 Ultra." />
  <style>
    :root{ --bg1:#0a0318; --bg2:#1a0b2e; --white:#ffffff; }
    html, body { height: 100%; }
    body{
      margin:0; overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--white);
      background: radial-gradient(1200px 800px at 70% 20%, #2a174a 0%, transparent 40%),
                  radial-gradient(1000px 700px at 20% 80%, #1e0f36 0%, transparent 45%),
                  radial-gradient(100% 120% at 50% 50%, var(--bg2), var(--bg1));
      background-attachment: fixed;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      touch-action: none;            /* pasamos gestos al lienzo */
      overscroll-behavior: none;     /* evita rebotes */
    }
    #scene { position: fixed; inset: 0; }
    #badge { position: fixed; left: 12px; bottom: env(safe-area-inset-bottom, 12px); opacity: .35; font-size: 12px; letter-spacing: .3px; }
  </style>
</head>
<body>
  <div id="scene" aria-label="Galaxia 3D con 'Te amo' en muchos idiomas"></div>
  <div id="badge" aria-hidden="true"></div>

  <!-- Código principal como ES Module utilizando URL explícitas (sin import maps) -->
  <script type="module">
  import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';

  (function(){
    'use strict';

    function ready(fn){ if (document.readyState !== 'loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }

    ready(()=>{
      try {
        // === Detección de dispositivo ===
        function deviceClass(){
          const w = Math.min(window.innerWidth, window.innerHeight);
          const h = Math.max(window.innerWidth, window.innerHeight);
          const approx = (a,b,eps)=> Math.abs(a-b) <= eps;
          if ( (approx(w,414,3) && approx(h,896,10)) ) return 'iphone11';
          if ( (approx(w,412,4) && approx(h,919,12)) ) return 's21u';
          if (w <= 430) return 'mobile';
          return 'desktop';
        }
        const DEV = deviceClass();
        const badge = document.getElementById('badge');
        if (badge) badge.textContent = DEV.toUpperCase();

        // === Three.js base ===
        const container = document.getElementById('scene');
        if (!container) throw new Error('Contenedor #scene no encontrado');

        const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
        const targetDPR = (DEV==='desktop') ? 2.5 : 2.0;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, targetDPR));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.style.touchAction = 'none';
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        if (DEV==='iphone11') camera.position.set(0, 16, 92);
        else if (DEV==='s21u') camera.position.set(0, 18, 96);
        else if (DEV==='mobile') camera.position.set(0, 18, 94);
        else camera.position.set(0, 18, 84);
        camera.lookAt(0,0,0);

        const galaxy = new THREE.Group();
        scene.add(galaxy);

        // Luces
        scene.add(new THREE.AmbientLight(0xffffff, 0.65));
        const dir = new THREE.DirectionalLight(0xffffff, 0.75); dir.position.set(60, 100, 40); scene.add(dir);

        // === Estrellas de fondo ===
        (function createStarfield(){
          const COUNT = (DEV==='desktop') ? 1600 : 1100;
          const geo = new THREE.BufferGeometry();
          const pos = new Float32Array(COUNT * 3);
          for (let i=0;i<COUNT;i++){
            const r = THREE.MathUtils.randFloat(180, 480);
            const phi = Math.random() * Math.PI * 2;
            const costheta = THREE.MathUtils.randFloat(-1, 1);
            const theta = Math.acos(costheta);
            pos[i*3+0] = r * Math.sin(theta) * Math.cos(phi);
            pos[i*3+1] = r * Math.sin(theta) * Math.sin(phi);
            pos[i*3+2] = r * Math.cos(theta);
          }
          geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
          const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.0, sizeAttenuation: true, transparent: true, opacity: 0.8 });
          galaxy.add(new THREE.Points(geo, mat));
        })();

        // === Galaxia espiral ===
        function createGalaxy(){
          const count = (DEV==='desktop') ? 12000 : 9000;
          const geo = new THREE.BufferGeometry();
          const pos = new Float32Array(count * 3);
          const col = new Float32Array(count * 3);
          const insideColor = new THREE.Color('#ff2d95');
          const outsideColor = new THREE.Color('#7c4dff');
          for (let i=0;i<count;i++){
            const r = Math.pow(Math.random(), 0.8) * 60;
            const branch = i % 5;
            const branchAngle = (branch / 5) * Math.PI * 2;
            const spinAngle = r * 1.4;
            const randomX = Math.pow(Math.random(), 2.6) * (Math.random()<0.5?1:-1) * 0.7 * r;
            const randomY = Math.pow(Math.random(), 2.6) * (Math.random()<0.5?1:-1) * 0.28 * r;
            const randomZ = Math.pow(Math.random(), 2.6) * (Math.random()<0.5?1:-1) * 0.7 * r;
            const x = Math.cos(branchAngle + spinAngle) * r + randomX;
            const y = randomY * 0.3;
            const z = Math.sin(branchAngle + spinAngle) * r + randomZ;
            pos[i*3+0]=x; pos[i*3+1]=y; pos[i*3+2]=z;
            const c = insideColor.clone().lerp(outsideColor, r / 60);
            col[i*3+0]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
          }
          geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
          geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
          const mat = new THREE.PointsMaterial({ size: (DEV==='desktop') ? 0.9 : 0.85, sizeAttenuation:true, depthWrite:false, blending: THREE.AdditiveBlending, vertexColors:true, transparent:true });
          const points = new THREE.Points(geo, mat);
          galaxy.add(points);
          return { geometry: geo, points };
        }
        const galaxyPoints = createGalaxy();

        // === "Te amo" en muchos idiomas (sin indicar idioma) ===
        const LOVE_PHRASES = [
          "Te amo","I love you","Je t'aime","Ti amo","Ich liebe dich","Eu te amo","Amo-te","S'agapo","Te iubesc","T'estimo",
          "Maite zaitut","Volim te","Kocham cię","Milujem ťa","Szeretlek","Ljublim te","Я тебя люблю","Я кохаю тебе",
          "أحبك","אני אוהב אותך","Seni seviyorum","تو را دوست دارم",
          "मैं तुमसे प्यार करता हूँ","আমি তোমাকে ভালবাসি","මම ඔයාට ආදරෙයි","ಮೆ ನಿನ್ನನ್ನು ಪ್ರೀತಿಸುತ್ತೇನೆ","நான் உன்னை காதலிக்கிறேன்","ഞാൻ നിന്നെ സ്നേഹിക്കുന്നു",
          "میں تم سے پیار کرتا ہوں","म तिमीलाई माया गर्छु","ང་ཁྱེད་ལ་དགའ་པོ་ཡོད་",
          "我爱你","我愛你","愛してる","사랑해","ຂ້ອຍຮັກເຈົ້າ","မင်းကိုချစ်တယ်","ខ្ញុំស្រឡាញ់អ្នក",
          "Aku cinta kamu","Mahal kita","Aroha ahau ki a koe","Aloha wau iā 'oe",
          "Nakupenda","Ndinokuda","Ek sê lief vir jou","Niyakuthanda","Mwen renmen ou",
          "Nimitztlazotla","Kuyayki","Rohayhu",
          "❤","♥","💜","💙","💖","💗"
        ];

        const labelGroup = new THREE.Group();
        galaxy.add(labelGroup);
        const sprites = [];

        // === Estilos de etiqueta (más pequeñas; más separación) ===
        function computeLabelStyle(){
          if (DEV==='iphone11'){
            return { fontSize: 20, padding: 6, baseHeight: 1.45, hoverScale: 1.07, minSep: 7.2, innerGap: 26 };
          }
          if (DEV==='s21u'){
            return { fontSize: 20, padding: 6, baseHeight: 1.5, hoverScale: 1.07, minSep: 7.2, innerGap: 26 };
          }
          if (DEV==='mobile'){
            return { fontSize: 22, padding: 7, baseHeight: 1.6, hoverScale: 1.07, minSep: 7.5, innerGap: 26 };
          }
          return { fontSize: 42, padding: 14, baseHeight: 2.6, hoverScale: 1.1, minSep: 7.5, innerGap: 24 };
        }
        let labelStyle = computeLabelStyle();

        function makeTextSprite(text){
          const { fontSize, padding } = labelStyle;
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          ctx.font = `700 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
          const metrics = ctx.measureText(text);
          const w = Math.ceil(metrics.width + padding * 2);
          const h = Math.ceil(fontSize + padding * 2);
          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          canvas.width = w * dpr; canvas.height = h * dpr;
          ctx.scale(dpr, dpr);
          ctx.fillStyle = 'rgba(255,255,255,0.08)';
          ctx.fillRect(0, 0, w, h);
          ctx.fillStyle = '#ffffff';
          ctx.strokeStyle = 'rgba(12,6,30,0.85)';
          ctx.lineWidth = Math.max(2, Math.floor(fontSize * 0.06));
          ctx.shadowColor = 'rgba(160,240,255,0.45)';
          ctx.shadowBlur = 9; ctx.shadowOffsetY = 1;
          ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
          ctx.font = `800 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
          // (no mostramos idioma; solo la frase)
          const clean = String(text).replace(/\s*\([^)]*\)\s*/g,' ').replace(/\s+/g,' ').trim();
          ctx.fillText(clean, padding, h/2 + 1);
          ctx.strokeText(clean, padding, h/2 + 1);
          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
          const material = new THREE.SpriteMaterial({ map: texture, transparent:true, depthWrite:false, depthTest:false });
          const sprite = new THREE.Sprite(material);
          const baseHeight = labelStyle.baseHeight;
          const aspect = canvas.width / canvas.height;
          sprite.scale.set(baseHeight * aspect, baseHeight, 1);
          sprite.userData = { baseHeight, text };
          return sprite;
        }

        function populatePhrasesOnGalaxy(list){
          // limpiar
          for (const s of sprites){ labelGroup.remove(s); s.material.map.dispose(); s.material.dispose(); }
          sprites.length = 0;

          const posAttr = galaxyPoints.geometry.getAttribute('position');
          const totalPos = posAttr.count;
          const INNER_GAP = labelStyle.innerGap;
          const MIN_SEP  = labelStyle.minSep;
          const isMobile = (DEV!=='desktop');
          const MAX_SPRITES = Math.min(list.length, Math.min(isMobile ? 80 : 140, totalPos));
          const STEP = Math.max(1, Math.floor(totalPos / MAX_SPRITES));

          function tooCloseXYZ(x,y,z){
            for (const s of sprites){
              const dx = x - s.position.x;
              const dz = z - s.position.z;
              const dy = (y - s.position.y) * 0.5;
              if (dx*dx + dz*dz + dy*dy < MIN_SEP*MIN_SEP) return true;
            }
            return false;
          }

          // Rejilla de ocupación en pantalla para evitar solapes visuales
          const gridW = isMobile ? 18 : 22; // columnas
          const gridH = isMobile ? 28 : 30; // filas
          const occupied = new Set();
          const keyOf = (nx,ny)=> nx+','+ny;

          for (let i=0; i<MAX_SPRITES; i++){
            const text = list[i % list.length];
            const sp = makeTextSprite(text);
            const base = i * STEP;
            const jitterSpan = Math.max(2, STEP * 0.25);
            let placed = false;
            for (let attempt=0; attempt<16 && !placed; attempt++){
              const jitter = Math.floor((Math.random() - 0.5) * jitterSpan);
              const idx = Math.min(totalPos - 1, Math.max(0, base + jitter));
              let x = posAttr.getX(idx);
              let y = posAttr.getY(idx);
              let z = posAttr.getZ(idx);
              const r2 = Math.hypot(x, z);
              if (r2 < INNER_GAP){
                const newR = INNER_GAP + Math.random() * 10;
                const scale = newR / (r2 || 1e-4);
                x *= scale; z *= scale;
              }
              x += (Math.random() - 0.5) * 3.2;
              z += (Math.random() - 0.5) * 3.2;

              // proyectar a NDC para reservar celda de pantalla
              const v = new THREE.Vector3(x,y,z); v.project(camera);
              if (v.z < -1 || v.z > 1) continue; // fuera de clip
              const nx = Math.floor((v.x*0.5+0.5) * gridW);
              const ny = Math.floor((-v.y*0.5+0.5) * gridH);
              const k = keyOf(nx,ny);
              if (occupied.has(k)) continue;

              if (!tooCloseXYZ(x,y,z)){
                sp.position.set(x, y, z);
                occupied.add(k);
                placed = true;
              }
            }

            if (!placed){
              // Empujar afuera como último recurso
              let x = posAttr.getX(base), y = posAttr.getY(base), z = posAttr.getZ(base);
              const r2 = Math.hypot(x, z); const newR = Math.max(INNER_GAP+14, r2 + 14);
              const scale = newR / (r2 || 1e-4);
              x *= scale; z *= scale; sp.position.set(x,y,z);
            }

            labelGroup.add(sp); sprites.push(sp);
          }
        }

        function shuffleArray(arr){ const a=[...arr]; for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
        function randomizePhrases(){
          const labels = shuffleArray([...LOVE_PHRASES, ...LOVE_PHRASES]); // duplicamos para densidad uniforme
          populatePhrasesOnGalaxy(labels);
        }
        randomizePhrases();

        // === Controles: 1 dedo rota galaxia; 2 dedos pinch-zoom + pan; rueda = zoom ===
        let controls = { update(){} };
        (function createBasicControls(){
          const dom = renderer.domElement;
          const state = { dragging:false, lastX:0, lastY:0, pointers:new Map(), lastDist:0, lastCentroid:null };

          function panBy(dx, dy){
            const panScale = (camera.position.z / Math.max(window.innerWidth, window.innerHeight)) * 1.2;
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
            const up = camera.up.clone().normalize();
            camera.position.addScaledVector(right, -dx * panScale);
            camera.position.addScaledVector(up,    dy * panScale);
            camera.lookAt(0,0,0);
          }

          dom.addEventListener('pointerdown', e=>{
            state.dragging=true; state.lastX=e.clientX; state.lastY=e.clientY; dom.setPointerCapture(e.pointerId);
            state.pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
          });
          dom.addEventListener('pointerup', e=>{
            state.dragging=false; state.pointers.delete(e.pointerId); state.lastDist=0; state.lastCentroid=null;
          });
          dom.addEventListener('pointercancel', e=>{
            state.dragging=false; state.pointers.clear(); state.lastDist=0; state.lastCentroid=null;
          });
          dom.addEventListener('pointermove', e=>{
            state.pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});

            // 1 dedo: rotación de galaxia
            if (state.pointers.size===1 && state.dragging){
              const dx = e.clientX - state.lastX; const dy = e.clientY - state.lastY;
              state.lastX = e.clientX; state.lastY = e.clientY;
              galaxy.rotation.y += dx * 0.005;
              galaxy.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, galaxy.rotation.x + dy * 0.003));
            }

            // 2 dedos: pinch + pan
            if (state.pointers.size===2){
              const pts = Array.from(state.pointers.values());
              const dx = pts[0].x - pts[1].x; const dy = pts[0].y - pts[1].y;
              const dist = Math.hypot(dx,dy);
              const centroid = { x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2 };
              if (state.lastDist){
                const delta = (state.lastDist - dist) * 0.02; // zoom
                camera.position.z = THREE.MathUtils.clamp(camera.position.z + delta, 20, 220);
              }
              if (state.lastCentroid){
                const cdx = centroid.x - state.lastCentroid.x; const cdy = centroid.y - state.lastCentroid.y;
                panBy(cdx, cdy);
              }
              state.lastDist = dist; state.lastCentroid = centroid;
            }
          }, { passive:true });

          dom.addEventListener('wheel', e=>{
            e.preventDefault();
            camera.position.z = THREE.MathUtils.clamp(camera.position.z + e.deltaY * 0.02, 20, 220);
          }, { passive:false });
        })();

        // === Hover sutil (agranda) ===
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(2,2); // fuera al inicio
        let hovered = null;
        function updateRaycast(){
          raycaster.setFromCamera(mouse, camera);
          const hit = raycaster.intersectObjects(sprites, false);
          if (hit.length){
            const obj = hit[0].object;
            if (hovered !== obj){
              if (hovered){ hovered.scale.set(hovered.userData.baseScaleX, hovered.userData.baseScaleY, 1); }
              hovered = obj;
              hovered.userData.baseScaleX = hovered.scale.x;
              hovered.userData.baseScaleY = hovered.scale.y;
              hovered.scale.set(hovered.scale.x * labelStyle.hoverScale, hovered.scale.y * labelStyle.hoverScale, 1);
            }
          } else {
            if (hovered){ hovered.scale.set(hovered.userData.baseScaleX, hovered.userData.baseScaleY, 1); }
            hovered = null;
          }
        }
        renderer.domElement.addEventListener('pointermove', e=>{
          const rect = renderer.domElement.getBoundingClientRect();
          mouse.set(((e.clientX-rect.left)/rect.width)*2-1, -((e.clientY-rect.top)/rect.height)*2+1);
        }, { passive:true });

        // === Resize ===
        window.addEventListener('resize', ()=>{
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          const newStyle = computeLabelStyle();
          if (newStyle.baseHeight !== labelStyle.baseHeight || newStyle.fontSize !== labelStyle.fontSize){
            labelStyle = newStyle; randomizePhrases();
          }
        });

        // === Animación ===
        let t0 = performance.now();
        function animate(){
          const now = performance.now();
          const dt = (now - t0) / 1000; t0 = now;
          galaxy.rotation.y += dt * 0.12;
          const wobble = 1 + Math.sin(now * 0.008) * 0.03;
          const camPos = camera.position;
          for (const s of sprites){
            const dist = s.position.distanceTo(camPos);
            const k = THREE.MathUtils.clamp(THREE.MathUtils.mapLinear(dist, 10, 180, 1.3, 4.0), 1.15, 4.2);
            const h = s.userData.baseHeight * k * wobble;
            const aspect = s.scale.x / s.scale.y;
            s.scale.set(h * aspect, h, 1);
            s.position.y += Math.sin(now * 0.001 + s.position.x * 0.02 + s.position.z * 0.02) * 0.0035;
          }
          updateRaycast();
          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        }
        animate();

        // === Self-tests mínimos ===
        setTimeout(()=>{
          const a0 = galaxy.rotation.y;
          setTimeout(()=>{ const a1 = galaxy.rotation.y; console.assert(a1 !== a0, 'La galaxia no está girando'); }, 160);
        }, 0);

      } catch (err) {
        const note = document.createElement('pre');
        note.textContent = 'Fallo de arranque: ' + (err && err.message ? err.message : err);
        Object.assign(note.style, {
          position:'fixed', left:'50%', top:'20px', transform:'translateX(-50%)',
          background:'rgba(0,0,0,.75)', color:'#fff', padding:'12px 16px', borderRadius:'12px',
          fontFamily:'monospace', fontSize:'12px', zIndex:9999,
          border:'1px solid rgba(255,255,255,.25)', maxWidth:'90vw', whiteSpace:'pre-wrap'
        });
        document.body.appendChild(note);
        console.error(err);
      }
    });
  })();
  </script>
</body>
</html>
